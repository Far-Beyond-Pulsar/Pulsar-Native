//! A node that yields control of the current thread to allow other threads to run.
//!
//! This node voluntarily gives up the remaining time slice of the current
//! thread, allowing the operating system scheduler to run other threads
//! that are ready to execute. The current thread will be rescheduled to
//! run again when the scheduler determines it's appropriate.
//!
//! # Inputs
//! - _None_
//!
//! # Outputs
//! - _None_ (side effect: yields the thread)
//!
//! # Example
//! Use this node inside a tight loop to allow other threads to run:
//! ```
//! while busy_condition {
//!     // ... do work ...
//!     thread_yield();
//! }
//! ```
//!
//! # Notes
//! This is a cooperative scheduling mechanism. The thread may resume
//! execution immediately if no other threads are ready to run, or it
//! may wait for other threads to execute first.
//! Useful in tight loops to prevent starving other threads, or in
//! cooperative multitasking scenarios where threads need to share CPU time.
///
/// Yield the current thread to allow other threads to run.
fn @[pulsar_node_fn_id]@() {
    std::thread::yield_now();
}