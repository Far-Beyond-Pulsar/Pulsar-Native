//! A node that executes a shell command with a timeout.
//!
//! This node runs the specified shell command and waits for it to complete, but will terminate the process if it exceeds the given timeout (in seconds).
//! Useful for automation, scripting, or running external tools where you want to avoid hanging or long-running processes.
//!
//! # Inputs
//! - `in_command_string`: The shell command to execute (string).
//! - `in_timeout_number`: The timeout duration in seconds (integer).
//!
//! # Outputs
//! - `Result<String, String>`: The standard output of the command if successful and completed within the timeout, or an error message if the command fails or times out.
//!
//! # Example
//! If `in_command_string` is "sleep 2" and `in_timeout_number` is 1, the command will be killed after 1 second and the output will be an error message ("Command timed out").
//! If the command completes in less than the timeout, its output is returned.
//!
//! # Notes
//! This implementation uses the system shell (`cmd` on Windows, `sh` on Unix-like systems).
//! The timeout is enforced by sleeping and checking process status; this is a simple simulation and may not be precise.
//! Use this node to prevent runaway or stuck processes in automation scripts or pipelines.
//!
//! # Errors
//! Returns an error if the command fails to execute, returns a non-zero exit code, or times out.

/// Execute a command with a timeout in seconds.
fn @[pulsar_node_fn_id]@() -> Result<String, String> {
    use std::process::{Command, Stdio};
    use std::time::Duration;
    
    let mut child = if cfg!(target_os = "windows") {
        Command::new("cmd")
            .args(["/C", @[in_command_string]@])
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
    } else {
        Command::new("sh")
            .args(["-c", @[in_command_string]@])
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
    };
    
    let mut child = match child {
        Ok(child) => child,
        Err(e) => return Err(format!("Failed to spawn process: {}", e)),
    };
    
    // Simple timeout simulation (not perfect but functional)
    std::thread::sleep(Duration::from_millis(100)); // Small delay to let process start
    
    match child.try_wait() {
        Ok(Some(status)) => {
            let output = child.wait_with_output().unwrap();
            if status.success() {
                Ok(String::from_utf8_lossy(&output.stdout).to_string())
            } else {
                Err(String::from_utf8_lossy(&output.stderr).to_string())
            }
        },
        Ok(None) => {
            // Process still running - for simplicity, we'll wait a bit more
            let timeout_secs = @[in_timeout_number]@ as u64;
            std::thread::sleep(Duration::from_secs(timeout_secs));
            
            match child.try_wait() {
                Ok(Some(status)) => {
                    let output = child.wait_with_output().unwrap();
                    if status.success() {
                        Ok(String::from_utf8_lossy(&output.stdout).to_string())
                    } else {
                        Err(String::from_utf8_lossy(&output.stderr).to_string())
                    }
                },
                _ => {
                    let _ = child.kill();
                    Err("Command timed out".to_string())
                }
            }
        },
        Err(e) => Err(format!("Error checking process status: {}", e)),
    }
}