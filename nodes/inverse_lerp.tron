//! A node that calculates the inverse of linear interpolation (inverse lerp).
//!
//! This node computes the parameter t such that value = lerp(a, b, t), given a, b, and value.
//! The result t is clamped to the range [0, 1]. Useful for normalizing values, mapping ranges, or extracting interpolation factors.
//!
//! # Inputs
//! - `in_a_number`: The start value (a).
//! - `in_b_number`: The end value (b).
//! - `in_value_number`: The value to find the interpolation parameter for.
//!
//! # Outputs
//! - The interpolation parameter t (float), clamped to [0, 1].
//!
//! # Example
//! If `in_a_number` is 0, `in_b_number` is 10, and `in_value_number` is 5, the output will be 0.5.
//! If a and b are equal, the output will be 0.0.
//!
//! # Notes
//! The formula is: t = (value - a) / (b - a), clamped to [0, 1]. If a == b, returns 0.0 to avoid division by zero.

/// Calculate the inverse of linear interpolation (find t given a, b, and result).
fn @[pulsar_node_fn_id]@() -> f32 {
    let a = @[in_a_number]@;
    let b = @[in_b_number]@;
    let value = @[in_value_number]@;
    
    if (b - a).abs() < f32::EPSILON {
        0.0
    } else {
        ((value - a) / (b - a)).clamp(0.0, 1.0)
    }
}