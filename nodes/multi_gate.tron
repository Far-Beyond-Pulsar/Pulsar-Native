//! A node that cycles through multiple outputs in sequence (like Unreal's MultiGate).
//!
//! This node maintains an internal index and cycles through multiple execution outputs each time it is triggered.
//! Useful for round-robin logic, distributing work, or sequencing actions across multiple branches.
//!
//! # Inputs
//! - `in_reset_bool`: If true, resets the internal index to zero.
//!
//! # Outputs
//! - Executes one of the outputs (`pulsar_exec_output0`, `pulsar_exec_output1`, etc.) in sequence each time the node is triggered.
//!
//! # Behavior
//! - On each trigger, the node increments its internal index and executes the corresponding output branch.
//! - When the index exceeds the number of outputs, it wraps around to zero.
//! - If `in_reset_bool` is true, the index is reset to zero and no output is executed.
//!
//! # Example
//! If connected to four print nodes, the output will cycle through printing "0", "1", "2", "3" on consecutive triggers, then repeat.
//!
//! # Notes
//! Uses a static atomic integer for thread-safe state tracking. The number of outputs is fixed to 4 for simplicity.
//! Extend the implementation for more outputs as needed.
//
/// Cycle through multiple outputs in sequence.
fn @[pulsar_node_fn_id]@() {
    use std::sync::atomic::{AtomicI32, Ordering};
    static CURRENT_INDEX: AtomicI32 = AtomicI32::new(0);

    if @[in_reset_bool]@ {
        CURRENT_INDEX.store(0, Ordering::Relaxed);
        return;
    }

    let index = CURRENT_INDEX.fetch_add(1, Ordering::Relaxed);
    let num_outputs = 4; // Fixed to 4 outputs for simplicity
    let current = index % num_outputs;

    match current {
        0 => @[pulsar_exec_output0]@,
        1 => @[pulsar_exec_output1]@,
        2 => @[pulsar_exec_output2]@,
        3 => @[pulsar_exec_output3]@,
        _ => {}
    }
}