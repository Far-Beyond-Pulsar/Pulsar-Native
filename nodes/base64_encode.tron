//! A node that encodes a string to base64.
//!
//! This node takes a string input and returns its base64-encoded representation.
//! The encoding uses the standard base64 alphabet and pads the output with '=' as needed.
//!
//! # Inputs
//! - `in_text_string`: The input string to encode.
//!
//! # Outputs
//! - The base64-encoded string.
//!
//! # Example
//! If `in_text_string` is "hello", the output will be "aGVsbG8=".
//!
//! # Notes
//! This implementation is basic and does not support URL-safe or MIME variants.
//! Padding is added as required for input lengths not divisible by 3.
//!
//! # Behavior
//! The output is always a valid base64 string, suitable for transmission or storage.
//
/// Encode a string to base64 (basic implementation).
fn @[pulsar_node_fn_id]@() -> String {
    let input = @[in_text_string]@;
    let alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    let mut result = String::new();
    let bytes = input.as_bytes();
    
    for chunk in bytes.chunks(3) {
        let mut buf = [0u8; 3];
        for (i, &byte) in chunk.iter().enumerate() {
            buf[i] = byte;
        }
        
        let b = ((buf[0] as u32) << 16) | ((buf[1] as u32) << 8) | (buf[2] as u32);
        
        result.push(alphabet.chars().nth(((b >> 18) & 63) as usize).unwrap());
        result.push(alphabet.chars().nth(((b >> 12) & 63) as usize).unwrap());
        
        if chunk.len() > 1 {
            result.push(alphabet.chars().nth(((b >> 6) & 63) as usize).unwrap());
        } else {
            result.push('=');
        }
        
        if chunk.len() > 2 {
            result.push(alphabet.chars().nth((b & 63) as usize).unwrap());
        } else {
            result.push('=');
        }
    }
    
    result
}