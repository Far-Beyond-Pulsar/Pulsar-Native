//! A node that URL-decodes a string.
//!
//! This node decodes a percent-encoded URL string, converting percent-encoded sequences (e.g., `%20`) back to their original characters.
//! It also converts plus signs (`+`) to spaces, as is common in URL query strings.
//!
//! # Inputs
//! - `in_text_string`: The percent-encoded string to decode.
//!
//! # Outputs
//! - `Result<String, String>`: The decoded string, or an error message if decoding fails.
//!
//! # Example
//! If `in_text_string` is "hello%20world%21", the output will be `Ok("hello world!")`.
//! If the input contains invalid percent-encoding, the output will be an error.
//!
//! # Notes
//! This is a basic implementation and may not handle all edge cases of URL encoding.
//!
//! This node decodes a percent-encoded URL string, converting percent-encoded sequences (e.g., `%20`) back to their original characters.
//! It also converts plus signs (`+`) to spaces, as is common in URL query strings.
//!
//! # Inputs
//! - `in_text_string`: The percent-encoded string to decode.
//!
//! # Outputs
//! - `Result<String, String>`: The decoded string, or an error message if decoding fails.
//!
//! # Example
//! If `in_text_string` is "hello%20world%21", the output will be `Ok("hello world!")`.
//! If the input contains invalid percent-encoding, the output will be an error.
//!
//! # Notes
//! This is a basic implementation and may not handle all edge cases of URL encoding.

/// URL-decode a string (basic implementation).
fn @[pulsar_node_fn_id]@() -> Result<String, String> {
    let input = @[in_text_string]@;
    let mut result = Vec::new();
    let mut chars = input.chars();
    
    while let Some(ch) = chars.next() {
        match ch {
            '%' => {
                let hex: String = chars.by_ref().take(2).collect();
                if hex.len() == 2 {
                    match u8::from_str_radix(&hex, 16) {
                        Ok(byte) => result.push(byte),
                        Err(_) => return Err("Invalid percent encoding".to_string()),
                    }
                } else {
                    return Err("Incomplete percent encoding".to_string());
                }
            },
            '+' => result.push(b' '),
            _ => {
                let mut buf = [0; 4];
                let bytes = ch.encode_utf8(&mut buf).as_bytes();
                result.extend_from_slice(bytes);
            }
        }
    }
    
    match String::from_utf8(result) {
        Ok(s) => Ok(s),
        Err(_) => Err("Invalid UTF-8 in decoded string".to_string()),
    }
}