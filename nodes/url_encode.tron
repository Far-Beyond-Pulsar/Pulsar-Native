//! A node that URL-encodes a string.
//!
//! This node takes an input string and returns a new string where all non-URL-safe characters
//! are percent-encoded according to the URL encoding rules. Alphanumeric characters and a few
//! special characters (- _ . ~) are left unchanged; all others are replaced with %XX hex codes.
//!
//! # Inputs
//! - `in_text_string`: The string to URL-encode.
//!
//! # Outputs
//! - `String`: The URL-encoded version of the input string.
//!
//! # Example
//! If `in_text_string` is "hello world!", the output will be "hello%20world%21".
//!
//! # Notes
//! This is a basic implementation and may not handle all edge cases for complex URLs.
//!
//! This node takes an input string and returns a new string where all non-URL-safe characters
//! are percent-encoded according to the URL encoding rules. Alphanumeric characters and a few
//! special characters (- _ . ~) are left unchanged; all others are replaced with %XX hex codes.
//!
//! # Inputs
//! - `in_text_string`: The string to URL-encode.
//!
//! # Outputs
//! - `String`: The URL-encoded version of the input string.
//!
//! # Example
//! If `in_text_string` is "hello world!", the output will be "hello%20world%21".
//!
//! # Notes
//! This is a basic implementation and may not handle all edge cases for complex URLs.

/// URL-encode a string (basic implementation).
fn @[pulsar_node_fn_id]@() -> String {
    let input = @[in_text_string]@;
    let mut result = String::new();
    for byte in input.as_bytes() {
        match *byte {
            b'A'..=b'Z' | b'a'..=b'z' | b'0'..=b'9' | b'-' | b'_' | b'.' | b'~' => {
                result.push(*byte as char);
            },
            _ => {
                result.push_str(&format!("%{:02X}", byte));
            }
        }
    }
    result
}