//! A node that parses a URL into components.
//!
//! This node splits a URL string into its main components: scheme, host, path, and query string.
//! It returns a tuple containing each part as a string. If the URL is invalid or missing a scheme,
//! an error is returned.
//!
//! # Inputs
//! - `in_url_string`: The URL string to parse.
//!
//! # Outputs
//! - `Result<(String, String, String, String), String>`: A tuple of (scheme, host, path, query) or an error message.
//!
//! # Example
//! If `in_url_string` is "https://example.com/path/to/page?foo=bar", the output will be
//! `Ok(("https", "example.com", "/path/to/page", "foo=bar"))`.
//!
//! # Notes
//! This is a basic parser and may not handle all edge cases or exotic URLs. The scheme must be present and separated by "://".
//!
//! This node splits a URL string into its main components: scheme, host, path, and query string.
//! It returns a tuple containing each part as a string. If the URL is invalid or missing a scheme,
//! an error is returned.
//!
//! # Inputs
//! - `in_url_string`: The URL string to parse.
//!
//! # Outputs
//! - `Result<(String, String, String, String), String>`: A tuple of (scheme, host, path, query) or an error message.
//!
//! # Example
//! If `in_url_string` is "https://example.com/path/to/page?foo=bar", the output will be
//! `Ok(("https", "example.com", "/path/to/page", "foo=bar"))`.
//!
//! # Notes
//! This is a basic parser and may not handle all edge cases or exotic URLs. The scheme must be present and separated by "://".

/// Parse a URL into its components (basic implementation).
fn @[pulsar_node_fn_id]@() -> Result<(String, String, String, String), String> {
    let url = @[in_url_string]@;
    
    // Split scheme
    let (scheme, rest) = if let Some(pos) = url.find("://") {
        (url[..pos].to_string(), &url[pos + 3..])
    } else {
        return Err("Invalid URL: missing scheme".to_string());
    };
    
    // Split host and path
    let (host, path) = if let Some(pos) = rest.find('/') {
        (rest[..pos].to_string(), rest[pos..].to_string())
    } else {
        (rest.to_string(), "/".to_string())
    };
    
    // Extract query (simple implementation)
    let (path, query) = if let Some(pos) = path.find('?') {
        (path[..pos].to_string(), path[pos + 1..].to_string())
    } else {
        (path, String::new())
    };
    
    Ok((scheme, host, path, query))
}