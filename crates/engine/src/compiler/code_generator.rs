//! # Code Generator
//!
//! The core code generation logic for transforming node graphs into Rust code.
//!
//! This module implements different generation strategies for each node type:
//! - **Pure nodes**: Recursively inlined as expressions where used (no allocations)
//! - **Function nodes**: Generate function calls with exec chain
//! - **Control flow nodes**: Inline function body with substitutions

use super::{
    ast_utils,
    data_resolver::DataResolver,
    execution_routing::ExecutionRouting,
    node_metadata::{NodeMetadata, NodeTypes},
};
use crate::graph::{ConnectionType, GraphDescription, NodeInstance};
use std::collections::{HashMap, HashSet};

/// Variable metadata for code generation
#[derive(Debug, Clone)]
pub struct VariableInfo {
    pub name: String,
    pub var_type: String,
}

/// Main code generator
pub struct CodeGenerator<'a> {
    /// Node metadata from pulsar_std
    metadata: &'a HashMap<String, NodeMetadata>,

    /// Data flow resolver
    data_resolver: &'a DataResolver,

    /// Execution routing table
    exec_routing: &'a ExecutionRouting,

    /// The graph being compiled
    graph: &'a GraphDescription,

    /// Class variables (name -> type)
    variables: HashMap<String, String>,

    /// Tracks visited nodes to prevent infinite loops
    visited: HashSet<String>,
}

impl<'a> CodeGenerator<'a> {
    pub fn new(
        metadata: &'a HashMap<String, NodeMetadata>,
        data_resolver: &'a DataResolver,
        exec_routing: &'a ExecutionRouting,
        graph: &'a GraphDescription,
        variables: HashMap<String, String>,
    ) -> Self {
        Self {
            metadata,
            data_resolver,
            exec_routing,
            graph,
            variables,
            visited: HashSet::new(),
        }
    }

    /// Generate code for an event entry point
    pub fn generate_event_function(&mut self, event_node: &NodeInstance) -> Result<String, String> {
        // Get event node metadata
        let node_meta = self
            .metadata
            .get(&event_node.node_type)
            .ok_or_else(|| format!("Unknown event node type: {}", event_node.node_type))?;

        if node_meta.node_type != NodeTypes::event {
            return Err(format!("Node {} is not an event node", event_node.id));
        }

        // Use the function name from the event definition
        let fn_name = &node_meta.name;

        let mut body = String::new();

        // Follow execution chain from event's "Body" output
        let connected_nodes = self
            .exec_routing
            .get_connected_nodes(&event_node.id, "Body");
        for target_id in connected_nodes {
            if let Some(target_node) = self.graph.nodes.get(target_id) {
                self.generate_exec_chain(target_node, &mut body, 1)?;
            }
        }

        // Generate file header
        let header = Self::generate_file_header(&format!("{} event", fn_name));

        // Add imports and function definition
        // Include vars import for accessing class variables
        Ok(format!(
            "{}\nuse pulsar_std::*;\nuse super::super::vars::*;\n\npub fn {}() {{\n{}}}\n",
            header, fn_name, body
        ))
    }

    /// Generate a standard file header for auto-generated code
    fn generate_file_header(description: &str) -> String {
        let now = chrono::Local::now();
        let version = crate::ENGINE_VERSION;
        format!(
            "//! Auto Generated by the Pulsar Blueprint Editor\n\
             //! DO NOT EDIT MANUALLY - YOUR CHANGES WILL BE OVERWRITTEN\n\
             //! Generated on {} - Engine version {}\n\
             //!\n\
             //! This file contains the {}.\n\
             //! To modify this event, open the class in the Pulsar Blueprint Editor\n\
             //! and make your changes visually in the node graph.\n\
             //!\n\
             //! EDITING ANYTHING IN THIS FILE COULD BREAK THE EDITOR\n\
             //! AND PREVENT THE GUI FROM OPENING THIS CLASS - BE CAREFUL\n",
            now.format("%Y-%m-%d %H:%M:%S"),
            version,
            description
        )
    }

    /// Generate execution chain starting from a node
    fn generate_exec_chain(
        &mut self,
        node: &NodeInstance,
        output: &mut String,
        indent_level: usize,
    ) -> Result<(), String> {
        // Prevent infinite loops
        if self.visited.contains(&node.id) {
            return Ok(());
        }
        self.visited.insert(node.id.clone());

        // Check if this is a variable getter or setter node
        if node.node_type.starts_with("get_") {
            // Getter nodes are pure (no exec chain), skip
            return Ok(());
        } else if node.node_type.starts_with("set_") {
            // Setter nodes have exec chain
            return self.generate_setter_node(node, output, indent_level);
        }

        let node_meta = self
            .metadata
            .get(&node.node_type)
            .ok_or_else(|| format!("Unknown node type: {}", node.node_type))?;

        match node_meta.node_type {
            NodeTypes::pure => {
                // Pure nodes are pre-evaluated, skip in exec chain
                Ok(())
            }

            NodeTypes::fn_ => {
                self.generate_function_node(node, node_meta, output, indent_level)
            }

            NodeTypes::control_flow => {
                self.generate_control_flow_node(node, node_meta, output, indent_level)
            }

            NodeTypes::event => {
                // Event nodes define the outer function, skip in exec chain
                // Their "Body" output defines where execution starts
                Ok(())
            }
        }
    }

    /// Generate code for a function node
    fn generate_function_node(
        &mut self,
        node: &NodeInstance,
        node_meta: &NodeMetadata,
        output: &mut String,
        indent_level: usize,
    ) -> Result<(), String> {
        let indent = "    ".repeat(indent_level);

        // Collect arguments
        let args = self.collect_arguments(node, node_meta)?;

        // Check if this function returns a value
        let has_return = node_meta.return_type.is_some();

        if has_return {
            // Store result in variable
            let result_var = self
                .data_resolver
                .get_result_variable(&node.id)
                .ok_or_else(|| format!("No result variable for node: {}", node.id))?;

            output.push_str(&format!(
                "{}let {} = {}({});\n",
                indent,
                result_var,
                node_meta.name,
                args.join(", ")
            ));
        } else {
            // Just call the function
            output.push_str(&format!(
                "{}{}({});\n",
                indent,
                node_meta.name,
                args.join(", ")
            ));
        }

        // Follow execution chain
        if let Some(exec_out) = node_meta.exec_outputs.first() {
            let connected = self.exec_routing.get_connected_nodes(&node.id, exec_out);
            for next_node_id in connected {
                if let Some(next_node) = self.graph.nodes.get(next_node_id) {
                    self.generate_exec_chain(next_node, output, indent_level)?;
                }
            }
        }

        Ok(())
    }

    /// Generate code for a control flow node (inline)
    fn generate_control_flow_node(
        &mut self,
        node: &NodeInstance,
        node_meta: &NodeMetadata,
        output: &mut String,
        indent_level: usize,
    ) -> Result<(), String> {
        let indent = "    ".repeat(indent_level);

        // Build exec_output replacements
        let mut exec_replacements = HashMap::new();
        eprintln!(
            "[CODEGEN] Building exec replacements for control flow node '{}'",
            node.node_type
        );
        eprintln!(
            "[CODEGEN] Node has {} exec outputs: {:?}",
            node_meta.exec_outputs.len(),
            node_meta.exec_outputs
        );

        for exec_pin in node_meta.exec_outputs.iter() {
            let connected = self.exec_routing.get_connected_nodes(&node.id, exec_pin);
            eprintln!(
                "[CODEGEN] Exec pin '{}' has {} connected nodes: {:?}",
                exec_pin,
                connected.len(),
                connected
            );

            let mut exec_code = String::new();
            let mut local_visited = self.visited.clone();

            for next_node_id in connected {
                if let Some(next_node) = self.graph.nodes.get(next_node_id) {
                    eprintln!(
                        "[CODEGEN] Generating code for connected node '{}'",
                        next_node.node_type
                    );
                    // Create a sub-generator with local visited set
                    let mut sub_gen = CodeGenerator {
                        metadata: self.metadata,
                        data_resolver: self.data_resolver,
                        exec_routing: self.exec_routing,
                        graph: self.graph,
                        variables: self.variables.clone(),
                        visited: local_visited.clone(),
                    };

                    sub_gen.generate_exec_chain(next_node, &mut exec_code, 0)?;
                    local_visited = sub_gen.visited;
                }
            }

            eprintln!(
                "[CODEGEN] Exec pin '{}' replacement code: '{}'",
                exec_pin,
                exec_code.trim()
            );
            exec_replacements.insert(exec_pin.to_string(), exec_code.trim().to_string());
        }

        eprintln!(
            "[CODEGEN] Final exec_replacements map: {:?}",
            exec_replacements
        );

        // Build parameter substitutions
        let mut param_substitutions = HashMap::new();
        for param in node_meta.params.iter() {
            let value =
                self.data_resolver
                    .generate_input_expression(&node.id, &param.name, self.graph)?;
            param_substitutions.insert(param.name.to_string(), value);
        }

        // Inline the function with substitutions
        let inlined_body = ast_utils::inline_control_flow_function(
            &node_meta.function_source,
            exec_replacements,
            param_substitutions,
        )?;

        // Add inlined code with proper indentation
        for line in inlined_body.lines() {
            if !line.trim().is_empty() {
                output.push_str(&format!("{}{}\n", indent, line));
            }
        }

        Ok(())
    }

    /// Collect arguments for a function call
    fn collect_arguments(
        &self,
        node: &NodeInstance,
        node_meta: &NodeMetadata,
    ) -> Result<Vec<String>, String> {
        let mut args = Vec::new();

        for param in node_meta.params.iter() {
            let value =
                self.data_resolver
                    .generate_input_expression(&node.id, &param.name, self.graph)?;
            args.push(value);
        }

        Ok(args)
    }

    /// Generate code for a variable setter node
    fn generate_setter_node(
        &mut self,
        node: &NodeInstance,
        output: &mut String,
        indent_level: usize,
    ) -> Result<(), String> {
        let indent = "    ".repeat(indent_level);

        // Extract variable name from node type (remove "set_" prefix)
        let var_name = node
            .node_type
            .strip_prefix("set_")
            .ok_or_else(|| format!("Invalid setter node type: {}", node.node_type))?;

        // Get the value to set from the "value" input pin
        let value_expr = self
            .data_resolver
            .generate_input_expression(&node.id, "value", self.graph)?;

        // Get variable type to determine Cell vs RefCell
        let var_type = self
            .variables
            .get(var_name)
            .ok_or_else(|| format!("Variable '{}' not found in variable definitions", var_name))?;

        // Determine if this is a Copy type (uses Cell) or not (uses RefCell)
        let is_copy_type = Self::is_copy_type(var_type);

        if is_copy_type {
            // Cell: VAR_NAME.with(|v| v.set(value));
            output.push_str(&format!(
                "{}{}.with(|v| v.set({}));\n",
                indent,
                var_name.to_uppercase(),
                value_expr
            ));
        } else {
            // RefCell: VAR_NAME.with(|v| *v.borrow_mut() = value);
            output.push_str(&format!(
                "{}{}.with(|v| *v.borrow_mut() = {});\n",
                indent,
                var_name.to_uppercase(),
                value_expr
            ));
        }

        // Follow execution chain from "exec_out" pin
        if node.outputs.iter().any(|p| p.id == "exec_out") {
            let connected = self.exec_routing.get_connected_nodes(&node.id, "exec_out");
            for next_node_id in connected {
                if let Some(next_node) = self.graph.nodes.get(next_node_id) {
                    self.generate_exec_chain(next_node, output, indent_level)?;
                }
            }
        }

        Ok(())
    }

    /// Check if a type is Copy (uses Cell) or not (uses RefCell)
    fn is_copy_type(type_str: &str) -> bool {
        matches!(
            type_str,
            "i32"
                | "i64"
                | "u32"
                | "u64"
                | "f32"
                | "f64"
                | "bool"
                | "char"
                | "usize"
                | "isize"
                | "i8"
                | "i16"
                | "u8"
                | "u16"
        )
    }
}

/// Extract unique crate dependencies needed by nodes in the graph
/// Returns a set of crate names that should be added to Cargo.toml
pub fn collect_node_dependencies(
    graph: &GraphDescription,
    metadata: &HashMap<String, NodeMetadata>,
) -> std::collections::HashSet<String> {
    use std::collections::HashSet;

    let mut dependencies = HashSet::new();

    // Iterate through all nodes in the graph
    for node in graph.nodes.values() {
        // Get metadata for this node type
        if let Some(node_meta) = metadata.get(&node.node_type) {
            // Extract crate name from each import
            for import in node_meta.imports {
                // Get the base crate name (before any ::)
                let crate_name = import.crate_name.split("::").next().unwrap_or(import.crate_name);

                // Skip standard library crates
                if !crate_name.starts_with("std") && !crate_name.starts_with("core") {
                    dependencies.insert(crate_name.to_string());
                }
            }
        }
    }

    dependencies
}

/// Collect all unique imports needed by nodes in the graph
fn collect_node_imports(
    graph: &GraphDescription,
    metadata: &HashMap<String, NodeMetadata>,
) -> Vec<String> {
    use std::collections::HashSet;

    let mut import_stmts = HashSet::new();

    // Iterate through all nodes in the graph
    for node in graph.nodes.values() {
        // Get metadata for this node type
        if let Some(node_meta) = metadata.get(&node.node_type) {
            // Process each import
            for import in node_meta.imports {
                let import_stmt = if import.items.is_empty() {
                    // Import entire crate: use crate_name;
                    format!("use {};", import.crate_name)
                } else if import.items.len() == 1 {
                    // Single item: use crate_name::item;
                    format!("use {}::{};", import.crate_name, import.items[0])
                } else {
                    // Multiple items: use crate_name::{item1, item2};
                    let items = import.items.join(", ");
                    format!("use {}::{{{}}};", import.crate_name, items)
                };
                import_stmts.insert(import_stmt);
            }
        }
    }

    // Convert to sorted vector for deterministic output
    let mut imports: Vec<_> = import_stmts.into_iter().collect();
    imports.sort();
    imports
}

/// Generate complete Rust program from graph
pub fn generate_program(
    graph: &GraphDescription,
    metadata: &HashMap<String, NodeMetadata>,
    data_resolver: &DataResolver,
    exec_routing: &ExecutionRouting,
    variables: HashMap<String, String>,
) -> Result<String, String> {
    let mut code = String::new();

    // Add imports
    code.push_str("// Auto-generated code from Pulsar Blueprint\n");
    code.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");
    code.push_str("use pulsar_std::*;\n");

    // Collect and add node-specific imports
    let node_imports = collect_node_imports(graph, metadata);
    for import_stmt in node_imports {
        code.push_str(&import_stmt);
        code.push_str("\n");
    }
    code.push_str("\n");

    // Find event nodes using metadata
    let event_nodes: Vec<_> = graph
        .nodes
        .values()
        .filter(|node| {
            // Check if this node's type is an event in metadata
            metadata
                .get(&node.node_type)
                .map(|meta| meta.node_type == NodeTypes::event)
                .unwrap_or(false)
        })
        .collect();

    if event_nodes.is_empty() {
        return Err(
            "No event nodes found in graph - add a 'main' or 'begin_play' event".to_string(),
        );
    }

    // Generate each event function
    for event_node in event_nodes {
        let mut generator = CodeGenerator::new(
            metadata,
            data_resolver,
            exec_routing,
            graph,
            variables.clone(),
        );
        let event_code = generator.generate_event_function(event_node)?;
        code.push_str(&event_code);
        code.push_str("\n");
    }

    Ok(code)
}

#[cfg(test)]
mod tests {
    use super::*;

    // TODO: Add tests once we have the full compiler pipeline
}
