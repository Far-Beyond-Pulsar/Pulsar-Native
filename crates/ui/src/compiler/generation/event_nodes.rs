//! # Event Node Code Generation
//!
//! Generates top-level functions from event nodes (entry points).
//!
//! Event nodes are special nodes that become entry points in the generated code:
//! - `main` - Main entry point
//! - `begin_play` - Called when actor begins play
//! - Custom events - User-defined entry points
//!
//! ## Generation Strategy
//!
//! Each event node becomes a top-level function with the execution chain
//! as its body.
//!
//! ## Example
//!
//! Graph: `main -> print("Hello, World!")`
//!
//! Generated:
//! ```rust,ignore
//! pub fn main() {
//!     print_string("Hello, World!".to_string());
//! }
//! ```

use crate::compiler::core::NodeTypes;
use crate::graph::NodeInstance;
use super::code_generator::CodeGenerator;

impl<'a> CodeGenerator<'a> {
    /// Generate code for an event entry point
    pub fn generate_event_function(&mut self, event_node: &NodeInstance) -> Result<String, String> {
        // Get event node metadata
        let node_meta = self
            .metadata
            .get(&event_node.node_type)
            .ok_or_else(|| format!("Unknown event node type: {}", event_node.node_type))?;

        if node_meta.node_type != NodeTypes::event {
            return Err(format!("Node {} is not an event node", event_node.id));
        }

        // Use the function name from the event definition
        let fn_name = &node_meta.name;

        let mut body = String::new();

        // Follow execution chain from event's "Body" output
        let connected_nodes = self
            .exec_routing
            .get_connected_nodes(&event_node.id, "Body");
        for target_id in connected_nodes {
            if let Some(target_node) = self.graph.nodes.get(target_id) {
                self.generate_exec_chain(target_node, &mut body, 1)?;
            }
        }

        // Generate file header
        let header = generate_file_header(&format!("{} event", fn_name));

        // Add imports and function definition
        // Include vars import for accessing class variables
        Ok(format!(
            "{}\nuse pulsar_std::*;\nuse super::super::vars::*;\n\npub fn {}() {{\n{}}}\n",
            header, fn_name, body
        ))
    }
}

/// Generate a standard file header for auto-generated code
pub fn generate_file_header(description: &str) -> String {
    let now = chrono::Local::now();
    let version = crate::ENGINE_VERSION;
    format!(
        "//! Auto Generated by the Pulsar Blueprint Editor\n\
         //! DO NOT EDIT MANUALLY - YOUR CHANGES WILL BE OVERWRITTEN\n\
         //! Generated on {} - Engine version {}\n\
         //!\n\
         //! This file contains the {}.\n\
         //! To modify this event, open the class in the Pulsar Blueprint Editor\n\
         //! and make your changes visually in the node graph.\n\
         //!\n\
         //! EDITING ANYTHING IN THIS FILE COULD BREAK THE EDITOR\n\
         //! AND PREVENT THE GUI FROM OPENING THIS CLASS - BE CAREFUL\n",
        now.format("%Y-%m-%d %H:%M:%S"),
        version,
        description
    )
}
