use anyhow::Result;
use std::path::{Path, PathBuf};
use super::utils::copy_dir_all;

// ============================================================================
// FILE OPERATIONS - Leverages engine_fs and extends with UI-specific ops
// ============================================================================

pub struct FileOperations {
    engine_fs: Option<engine_fs::EngineFs>,
}

impl FileOperations {
    pub fn new(project_root: Option<PathBuf>) -> Self {
        let engine_fs = project_root.and_then(|root| {
            match engine_fs::EngineFs::new(root) {
                Ok(fs) => {
                    // Register the TypeDatabase with global EngineContext
                    if let Some(engine_context) = engine_state::EngineContext::global() {
                        engine_context.set_type_database(fs.type_database().clone());
                        tracing::debug!("ðŸ—„ï¸  TypeDatabase registered with {} types",
                            fs.type_database().all().len());
                    }
                    Some(fs)
                }
                Err(e) => {
                    tracing::error!("Failed to create EngineFs: {}", e);
                    None
                }
            }
        });

        Self { engine_fs }
    }

    /// Create a new folder
    pub fn new_folder(base_path: &Path) -> Result<PathBuf> {
        let mut counter = 1;
        let mut new_path = base_path.join("NewFolder");

        while new_path.exists() {
            new_path = base_path.join(format!("NewFolder{}", counter));
            counter += 1;
        }

        std::fs::create_dir_all(&new_path)?;
        Ok(new_path)
    }

    /// Create a new file
    pub fn new_file(base_path: &Path) -> Result<PathBuf> {
        let mut counter = 1;
        let mut new_path = base_path.join("newfile.txt");

        while new_path.exists() {
            new_path = base_path.join(format!("newfile{}.txt", counter));
            counter += 1;
        }

        std::fs::write(&new_path, "")?;
        Ok(new_path)
    }

    /// Create a new Blueprint class (uses engine_fs if available)
    pub fn new_class(&self, base_path: &Path, name: Option<&str>) -> Result<PathBuf> {
        // If we have engine_fs, use it to create the asset properly
        if let Some(ref fs) = self.engine_fs {
            let class_name = name.unwrap_or("NewClass");
            return fs.operations().create_asset(
                engine_fs::AssetKind::BlueprintClass,
                class_name,
                Some(base_path.to_str().unwrap_or(".")),
            );
        }

        // Fallback: manual creation
        let mut counter = 1;
        let mut new_path = base_path.join(name.unwrap_or("NewClass"));

        while new_path.exists() {
            new_path = base_path.join(format!("NewClass{}", counter));
            counter += 1;
        }

        // Create class folder and events subfolder
        std::fs::create_dir_all(&new_path.join("events"))?;

        // Create graph_save.json with template
        let now = chrono::Local::now();
        let version = ui::ENGINE_VERSION;
        let header = format!(
            "// Auto Generated by the Pulsar Blueprint Editor\n\
             // DO NOT EDIT MANUALLY - YOUR CHANGES WILL BE OVERWRITTEN\n\
             // Generated on {} - Engine version {}\n\n",
            now.format("%Y-%m-%d %H:%M:%S"),
            version
        );

        let empty_graph = ui::graph::GraphDescription {
            nodes: std::collections::HashMap::new(),
            connections: Vec::new(),
            metadata: ui::graph::GraphMetadata {
                name: new_path.file_name()
                    .and_then(|n| n.to_str())
                    .unwrap_or("NewClass")
                    .to_string(),
                description: String::from("New class"),
                version: ui::ENGINE_VERSION.to_string(),
                created_at: now.to_rfc3339(),
                modified_at: now.to_rfc3339(),
            },
            comments: Vec::new(),
        };

        let json = serde_json::to_string_pretty(&empty_graph)?;
        let content = format!("{}{}", header, json);
        std::fs::write(new_path.join("graph_save.json"), content)?;

        Ok(new_path)
    }

    /// Delete an item (uses engine_fs if it's an asset)
    pub fn delete_item(&self, item_path: &Path) -> Result<()> {
        // Try engine_fs first for tracked assets
        if let Some(ref fs) = self.engine_fs {
            if let Ok(_) = fs.operations().delete_asset(&item_path.to_path_buf()) {
                return Ok(());
            }
        }

        // Fallback: direct filesystem deletion
        if item_path.is_dir() {
            std::fs::remove_dir_all(item_path)?;
        } else {
            std::fs::remove_file(item_path)?;
        }
        Ok(())
    }

    /// Duplicate an item
    pub fn duplicate_item(item_path: &Path) -> Result<PathBuf> {
        let parent = item_path.parent()
            .ok_or_else(|| anyhow::anyhow!("No parent directory"))?;
        let stem = item_path.file_stem()
            .and_then(|s| s.to_str())
            .unwrap_or("copy");
        let extension = item_path.extension()
            .and_then(|s| s.to_str())
            .unwrap_or("");

        let mut counter = 1;
        let mut new_path = if extension.is_empty() {
            parent.join(format!("{}_copy", stem))
        } else {
            parent.join(format!("{}_copy.{}", stem, extension))
        };

        while new_path.exists() {
            new_path = if extension.is_empty() {
                parent.join(format!("{}_copy{}", stem, counter))
            } else {
                parent.join(format!("{}_copy{}.{}", stem, counter, extension))
            };
            counter += 1;
        }

        if item_path.is_dir() {
            copy_dir_all(item_path, &new_path)?;
        } else {
            std::fs::copy(item_path, &new_path)?;
        }

        Ok(new_path)
    }

    /// Rename an item (uses engine_fs for tracked assets)
    pub fn rename_item(&self, old_path: &Path, new_name: &str) -> Result<PathBuf> {
        let parent = old_path.parent()
            .ok_or_else(|| anyhow::anyhow!("No parent directory"))?;
        let new_path = parent.join(new_name);

        if old_path == new_path {
            return Ok(new_path);
        }

        // Try engine_fs first for tracked assets
        if let Some(ref fs) = self.engine_fs {
            if let Ok(_) = fs.operations().move_asset(
                &old_path.to_path_buf(),
                &new_path
            ) {
                return Ok(new_path);
            }
        }

        // Fallback: direct filesystem rename
        std::fs::rename(old_path, &new_path)?;
        Ok(new_path)
    }

    /// Copy items to a target folder
    pub fn copy_items(source_paths: &[PathBuf], target_folder: &Path) -> Result<()> {
        for source_path in source_paths {
            if let Some(file_name) = source_path.file_name() {
                let target_path = target_folder.join(file_name);

                if source_path.is_dir() {
                    copy_dir_all(source_path, &target_path)?;
                } else {
                    std::fs::copy(source_path, &target_path)?;
                }
            }
        }
        Ok(())
    }

    /// Move items to a target folder (uses engine_fs for tracked assets)
    pub fn move_items(&self, source_paths: &[PathBuf], target_folder: &Path) -> Result<()> {
        for source_path in source_paths {
            if let Some(file_name) = source_path.file_name() {
                let target_path = target_folder.join(file_name);

                // Try engine_fs first
                if let Some(ref fs) = self.engine_fs {
                    if let Ok(_) = fs.operations().move_asset(source_path, &target_path) {
                        continue;
                    }
                }

                // Fallback: direct filesystem move
                std::fs::rename(source_path, &target_path)?;
            }
        }
        Ok(())
    }

    /// Get access to the underlying engine_fs (if available)
    pub fn engine_fs(&self) -> Option<&engine_fs::EngineFs> {
        self.engine_fs.as_ref()
    }
}
